{"name":"30log","tagline":"A 30-lines library for object-orientation in Lua","body":"30log\r\n=====\r\n\r\n[![Build Status](https://travis-ci.org/Yonaba/30log.png)](https://travis-ci.org/Yonaba/30log)\r\n[![Coverage Status](https://coveralls.io/repos/Yonaba/30log/badge.png?branch=master)](https://coveralls.io/r/Yonaba/30log?branch=master)\r\n[![License](http://img.shields.io/badge/Licence-MIT-brightgreen.svg)](LICENSE)\r\n\r\n__30log__, in extenso *30 Lines Of Goodness* is a minified framework for [object-orientation](http://lua-users.org/wiki/ObjectOrientedProgramming) in Lua.\r\nIt features __named (and unnamed) classes__, __single inheritance__ and a basic support for __mixins__.<br/>\r\nIt makes __30 lines__. No less, no more.<br/>\r\n__30log__ was written with [Lua 5.1](http://www.lua.org/versions.html#5.1) in mind, but is compatible with [Lua 5.2](http://www.lua.org/versions.html#5.2).\r\n\r\n\r\n# <a name='TOC'>Table of Contents</a>\r\n\r\n* [Download](#download)\r\n* [Adding *30log* to your code](#add30log)\r\n* [Quicktour](#quicktour)\r\n\t* [Declaring classes](#declaring)\r\n\t* [Creating instances](#instances)\r\n\t\t* [The `class:new()` method](http://github.com/Yonaba/30log/#class:new)\r\n\t\t* [The `class()` call way](http://github.com/Yonaba/30log/#class())\r\n\t\t* [`class:init(...)`](http://github.com/Yonaba/30log/#class:init)\r\n\t\t* [Some other features of instances](http://github.com/Yonaba/30log/#someother)\r\n\t* [Methods and metamethods](#methods)\r\n\t* [Inheritance](#inheritance)\r\n\t* [Introspection](#introspection)\r\n\t\t* [`class.isClass(class, super)`](http://github.com/Yonaba/30log/#class.isClass)\r\n\t\t* [`class.isInstance(instance, class)`](http://github.com/Yonaba/30log/#class.isInstance)\r\n\t\t* [`class:extends()`](http://github.com/Yonaba/30log/#class:extends)\r\n\t* [Mixins](#mixins)\r\n* [Class-Commons](#classcommons)\r\n* [Specification](#spec)\r\n* [About the source](#aboutsource)\r\n* [Contributors](#contrib)\r\n* [License](#license)\r\n\r\n\r\n# <a name='download'>Download</a>\r\n\r\n#### Bash\r\n\r\n```\r\ngit clone git://github.com/Yonaba/30log.git\r\n```\r\n\r\n#### Archive\r\n\r\n* __zip__: [1.0.0](https://github.com/Yonaba/30log/archive/30log-1.0.0.zip) (*latest stable, recommended*) | [older versions](https://github.com/Yonaba/30log/tags)\r\n* __tar.gz__: [1.0.0](https://github.com/Yonaba/30log/archive/30log-1.0.0.tar.gz) (*latest stable, recommended*) | [older versions](https://github.com/Yonaba/30log/tags)\r\n\r\n\r\n#### LuaRocks\r\n\r\n```\r\nluarocks install 30log\r\n```\r\n\r\n####MoonRocks\r\n\r\n```\r\nmoonrocks install 30log\r\n```\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n# <a name='add30log'>Adding 30log to your code</a>\r\n\r\nCopy the file [30log.lua](https://github.com/Yonaba/30log/blob/master/30log.lua) inside your project folder,\r\ncall it using [require](http://pgl.yoyo.org/luai/i/require) function. It will return a local table, keeping safe the global environment.<br/>\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n# <a name='quicktour'>A quicktour of the library</a>\r\n\r\n## <a name='declaring'>Declaring classes</a>\r\n\r\nLet us create a `Window` class.\r\n\r\n```lua\r\nclass = require \"30log\"\r\nWindow = class(\"Window\")\r\n````\r\n\r\nThat's it. The first argument is the name of the class (defined as string).\r\nLater, we can query that name by indexing the `.name` key. This argument is __optional__.\r\n\r\n```lua\r\nprint(Window.name) -- \"Window\"\r\n````\r\n\r\nCustom attributes can be added to any class. Here, we can define a \"width\" and \"height\" attributes and assign them values.\r\n\r\n```lua\r\nWindow.width, Window.height = 100,100\r\n```\r\n\r\nBut we could have also have the same result by passing a table with named keys as a `params` argument when declaring the `Window` class. This argument is also __optional__.\r\n\r\n```lua\r\nWindow = class(\"Window\", {width = 150, height = 100})\r\nprint(Window.width) -- 150\r\nprint(Window.height) -- 100\r\n```\r\n\r\nWhen a class has a `.name` attribute, it is considered to be a __named class__. In that case, passing that class to `tostring` or any function that triggers its `__tostring` metamethod returns the following:\r\n\r\n```lua\r\nprint(Window) -- \"class 'Window' (table: 0x0002cdc0)\"\r\n````\r\n\r\nIn case the class has no name, it is considered to be an __unnamed class__. In that case, when passing it to a function like `print` or `tostring`, the output is slightly different.\r\n\r\n```lua\r\nWindow = class(nil, {width = 150, height = 100}) -- no name argument specified\r\nprint(Window.name) -- nil\r\nprint(Window.width) -- 150\r\nprint(Window.height) -- 100\r\nprint(Window) -- \"class '?' (table: 0x0002cdb8)\"\r\n````\r\n\r\nThe ability to turn classes to string is mostly meant for debugging purposes. One can change this behavior by modifying the `__tostring` function of any class metatable.\r\n\r\n```lua\r\nWindow = class('Window')\r\ngetmetatable(Window).__tostring = function(t)\r\n  return \"I am class \"..(t.name or \"unnamed\")\r\nend\r\nprint(Window) -- \"I am class Window\"\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n## <a name='instances'>Creating instances</a>\r\n\r\n### <a name='class:new'>The `class:new()` method</a>\r\n\r\nAn instance of class is created using the class method `new()`:\r\n\r\n```lua\r\nappWindow = Window:new()\r\n````\r\n\r\nOnce created, an instance can access its class attributes. \r\n\r\n```lua\r\nprint(appWindow.width,appWindow.height) -- 100, 100\r\n````\r\n\r\nBut this instance has its own copy of those attributes. Changing them will affect neither the class itself, nor any other instance.\r\n\r\n```lua\r\n-- assigning new values to the instance attributes\r\nappWindow.width, appWindow.height = 720, 480\r\nprint(appWindow.width,appWindow.height) -- 720, 480\r\n\r\n-- Class attributes are left untouched\r\nprint(Window.width, Window.height) -- 100, 100\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n### <a name='class()'>The `class()` call way</a>\r\n\r\nAn instance can also be created calling the class itself as a function. It is just a syntactic sugar.\r\n\r\n```lua\r\nappWindow = Window() -- same as Window:new()\r\nprint(appWindow.width,appWindow.height) -- 100, 100\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n### <a name='class:init'>`class:init(...)`</a>\r\n\r\nFrom the two examples above, you might have noticed that once an instance is created from a class, it already shares the properties of his mother class.\r\n\r\nYet, instances can be initialized when creating them from a class. In this way, they already have their attributes set with custom values right after being created.\r\n\r\nIt just requires to implement a  __class constructor__. Typically, it is a method (a function) that will be called right after `class:new()` method. The class constructor will take as a first argument the `instance` and customize it.<br/>\r\n__30log__ uses the reserved key `init` for __class constructors__.\r\n\r\n```lua\r\nWindow = class(\"Window\")\r\nfunction Window:init(width,height)\r\n  self.width,self.height = width,height\r\nend\r\n\r\nappWindow = Window:new(800,600) -- or appFrame = Window(800,600)\r\nprint(appWindow.width,appWindow.height) -- 800, 600\r\n```\r\n\r\n`init` can also be defined as a table with named keys, instead of a function. In that case, any new instance created will get a raw copy of the keys and values found in this table.\r\n\r\n```lua\r\nWindow = class(\"Window\")\r\nWindow.init = { width = 500, height = 500}\r\n\r\nappWindow = Window()\r\nprint(appFrame.width,appFrame.height) --> 500, 500\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n### <a name='someother'>some other features of instances`</a>\r\n\r\nPassing an instance to `print` or `tostring` returns a string representing the instance itself. As for classes, this behavior is meant for debugging. And it can be customized from the user code.\r\n\r\n```lua\r\n-- example with a named class\r\nWindow = class(\"Window\")\r\nappWindow = Window()\r\nprint(appWindow) -- \"instance of 'Window' (table: 0x0002cf70)\"\r\n\r\n-- example with an unnamed class\r\nWindow = class()\r\nappWindow = Window()\r\nprint(appWindow) -- \"instance of '?' (table: 0x0002cf70)\"\r\n````\r\n\r\nAny instance has an attribute `.class` which points to its class.\r\n\r\n```lua\r\nWindow = class(\"Window\")\r\nappWindow = Window()\r\nprint(appWindow.class) -- \"class 'Window' (table: 0x0002cdf8)\"\r\n````\r\n\r\nAlso, *30log* classes are metatables of their own instances. This implies that one can inspect the relationship between a class and its instances via Lua's standard function [getmetatable](http://www.lua.org/manual/5.2/manual.html#pdf-getmetatable).\r\n\r\n```lua\r\nlocal aClass = class()\r\nlocal someInstance = aClass()\r\nprint(getmetatable(someInstance) == aClass) -- true\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n## <a name='methods'>Methods and metamethods</a>\r\n \r\nInstances have access their class __methods__.\r\n\r\n```lua\r\nWindow = class(\"Window\", {width = 100, height = 100})\r\n\r\nfunction Window:init(width,height)\r\n  self.width,self.height = width,height\r\nend\r\n\r\nfunction Window:cap(maxWidth, maxHeight)\r\n  self.width = math.max(self.width, maxWidth)\r\n  self.height = math.max(self.height, maxHeight)\r\nend\r\n\r\nappWindow = Window(200, 200)\r\nappWindow:cap(Window.width, Window.height)\r\nprint(appWindow.width,appWindow.height) -- 100,100\r\n```\r\n\r\nInstances cannot be used to instantiate new objects though. They are not meant for this.\r\n\r\n```lua\r\nappWindow = Window:new()\r\naWindow = appWindow:new() -- Creates an error\r\naWindow = appWindow()     -- Also creates an error\r\n````\r\n\r\nClasses support metamethods as well as methods. Those metamethods are inherited by subclasses.\r\n\r\n```lua\r\nfunction Window:__add(size) \r\n  self.width = self.width + size\r\n  self.height = self.height + size\r\n  return self\r\nend\r\n\r\nlocal window = Window(600,300)      -- creates a new Window instance\r\nprint(window.width, window.height)  -- 600, 300\r\nwindow = window + 100               -- increases dimensions\r\nprint(window.width, window.height)  -- 700, 400\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n## <a name='inheritance'>Inheritance</a>\r\n\r\nA subclass can be derived from a class from any other class using a reserved method named `extend`. Similarly to `class`, this method also takes an __optional__ argument `name` and an __optional__ table with named keys `params` as arguments.\r\n\r\nThe new subclass will inherit his superclass __attributes__ and __methods__.\r\n\r\n```lua\r\nWindow = class (\"Window\",{ width = 100, height = 100})\r\nFrame = Window:extend(\"Frame\", { color = \"black\" })\r\n\r\nappFrame = Frame()\r\nprint(appFrame.width, appFrame.height, appFrame.color) -- 100,100,\"black\"\r\n```\r\n\r\nAny subclass has a `.super` attribute which points to its superclass.\r\n\r\n```lua\r\nprint(Frame.super) -- \"class 'Window' (table: 0x0002ceb8)\"\r\n````\r\n\r\nA subclass can __redefine any method__ implemented in its superclass without affecting the superclass method itself.\r\nAlso, the subclass *still* has access to his mother class methods and properties via a the `super` key.\r\n\r\n```lua\r\n-- A base class \"Window\"\r\nWindow = class (\"Window\", {x = 10, y = 10, width = 100, height = 100})\r\n\r\nfunction Window:init(x, y, width, height)\r\n  Window.set(self, x, y, width, height)\r\nend\r\n\r\nfunction Window:set(x, y, w, h)\r\n  self.x, self.y, self.width, self.height = x, y, w, h\r\nend\r\n\r\n-- a \"Frame\" subclass\r\nFrame = Window:extend({color = 'black'})\r\nfunction Frame:init(x, y, width, height, color)\r\n  -- Calling the superclass constructor\r\n  Frame.super.init(self, x, y, width, height)\r\n  \r\n  -- Setting the extra class member\r\n  self.color = color\r\nend\r\n\r\n-- Redefining the set() method\r\nfunction Frame:set(x,y)\r\n  self.x = x - self.width/2\r\n  self.y = y - self.height/2\r\nend\r\n\r\n-- An appFrame from \"Frame\" class\r\nappFrame = Frame(100,100,800,600,'red')\r\nprint(appFrame.x,appFrame.y) -- 100, 100\r\n\r\n-- Calls the new set() method\r\nappFrame:set(400,400)\r\nprint(appFrame.x,appFrame.y) -- 0, 100\r\n\r\n-- Calls the old set() method in the mother class \"Windows\"\r\nappFrame.super.set(appFrame,400,300)\r\nprint(appFrame.x,appFrame.y) -- 400, 300\r\n```\r\n\r\nAlso, classes are metatables of their subclasses.\r\n\r\n```lua\r\nlocal aClass = class(\"aClass\")\r\nlocal someDerivedClass = aClass:extend()\r\nprint(getmetatable(someDerivedClass)) -- \"class 'aClass' (table: 0x0002cee8)\"\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n## <a name='introspection'>Introspection</a>\r\n\r\n### <a name='class.isClass'>`class.isClass(class, super)`</a>\r\n\r\n`class.isClass` returns true if the only argument given, `class`, is a *30log* class.\r\n\r\n```lua\r\nlocal aClass = class()\r\nlocal notaClass = {}\r\nprint(class.isClass(aClass)) -- true\r\nprint(class.isClass(notaClass)) -- false\r\n````\r\n\r\nIf a second argument `super` is passed, it returns true if and only if `class` is an immediate subclass of `super`.\r\n\r\n```lua\r\nlocal superclass = class()\r\nlocal subclass = superclass:extend()\r\nprint(class.isClass(subclass, superclass)) -- true \r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n### <a name='class.isInstance'>`class.isInstance(instance, class)`</a>\r\n\r\n`class.isInstance` returns true if the only argument given, `instance`, is an instance of a *30log* class.\r\n\r\n```lua\r\nlocal aClass = class()\r\nlocal instance = aClass()\r\nlocal noinstance = {}\r\nprint(class.isInstance(instance)) -- true\r\nprint(class.isInstance(noinstance)) -- false\r\n````\r\n\r\nIf a second argument `class` is passed, it returns true if and only if `instance` is an instance of `class`.\r\n\r\n```lua\r\nlocal aClass = class()\r\nlocal instance = aClass()\r\nprint(class.isInstance(instance, aClass)) -- true \r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n### <a name='class:extends'>`class:extends()`</a>\r\n\r\n`class:extends()` returns true if a class derives from a superclass, even if the superclass is not an immediate ancestor.\r\n\r\n```lua\r\nlocal superclass = class()\r\nlocal subclass = superclass:extend():extend():extend()\r\nprint(subclass:extends(superclass)) -- true\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n## <a name='mixins'>Mixins</a>\r\n\r\n__30log__ provides a basic support for [mixins](http://en.wikipedia.org/wiki/Mixin). This is a powerful concept that can be used to share the same functionality among different classes even if they are unrelated.\r\n\r\n__30log__ assumes a `mixin` to be a table containing a **set of methods** (functions). A mixin is included in a class using `class:include()` method: \r\n\r\n```lua\r\n-- A mixin\r\nGeometry = {\r\n  getArea = function(self) return self.width * self.height end,\r\n}\r\n\r\n-- Let us define two unrelared classes\r\nWindow = class (\"Window\", {width = 480, height = 250})\r\nButton = class (\"Button\", {width = 100, height = 50, onClick = false})\r\n\r\n-- Include the \"Geometry\" mixin\r\nWindow:include(Geometry)\r\nButton:include(Geometry)\r\n\r\n-- Let us define instances from those classes\r\nlocal aWindow = Window()\r\nlocal aButton = Button()\r\n\r\n-- Instances can use functionalities brought by the mixin.\r\nprint(aWindow:getArea()) -- 120000\r\nprint(aButton:getArea()) -- 5000\r\n````\r\n\r\nIt is possible to check if a class includes a particular mixin using `class:includes()`.\r\n\r\n```lua`\r\nprint(Window:includes(Geometry)) -- true\r\nprint(Button:includes(Geometry)) -- true\r\n````\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n# <a name='classcommons'>Class-Commons</a>\r\n\r\n[Class-Commons](https://github.com/bartbes/Class-Commons) is an interface that provides a common API for a wide range of object orientation libraries in Lua. There is a small plugin, originally written by [TsT](https://github.com/tst2005) \r\nwhich provides compatibility between *30log* and *Class-commons*. <br/>\r\nSee here: [30logclasscommons](http://github.com/Yonaba/30logclasscommons).\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n# <a name='spec'>Specification</a>\r\n\r\nYou can run the included specs with [Telescope](https://github.com/norman/telescope) using the following command from Lua from the root foolder:\r\n\r\n```\r\nlua tsc -f specs/*\r\n```\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n# <a name='aboutsource'>About the source</a>\r\n\r\n####30logclean.lua\r\n*30log* was initially designed for minimalistic purposes. But then commit after commit, I came up with a source code that was obviously surpassing 30 lines. As I wanted to stick to the \"30-lines\" rule that defines the name of this library, I had to use an ugly syntax which not much elegant, yet 100 % functional.<br/>\r\nFor those who might be interested though, the file [30logclean.lua](http://github.com/Yonaba/30log/blob/master/30logclean.lua) contains the full source code, properly formatted and well indented for your perusal.\r\n\r\n####30logglobal.lua\r\nThe file [30logglobal.lua](http://github.com/Yonaba/30log/blob/master/30logglobal.lua) features the exact same source as the original [30log.lua](http://github.com/Yonaba/30log/blob/master/30log.lua), \r\nexcepts that it sets a global named `class`. This is convenient for Lua-based frameworks such as [Codea](http://twolivesleft.com/Codea/).\r\n\r\n####Benchmark\r\nPerformance tests featuring classes creation, instantiation and such have been included. You can run these tests with the following command with Lua from the root folder, passing to the test script the actual implementation to be tested.\r\n\r\n```lua\r\nlua performance/test.lua 30log\r\n````\r\n\r\nFind [here an example of output](https://github.com/Yonaba/30log/tree/master/performance/results.md) for the latest version of *30log*.\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n# <a name='contrib'>Contributors</a>\r\n\r\n* [TsT2005](https://github.com/tst2005), for the original Class-commons support.\r\n\r\n\r\n**[[⬆]](#TOC)**\r\n\r\n# <a name='license'>License</a>\r\n\r\nThis work is under [MIT-LICENSE](http://www.opensource.org/licenses/mit-license.php)<br/>\r\nCopyright (c) 2012-2015 Roland Yonaba\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a\r\n    copy of this software and associated documentation files (the\r\n    \"Software\"), to deal in the Software without restriction, including\r\n    without limitation the rights to use, copy, modify, merge, publish,\r\n    distribute, sublicense, and/or sell copies of the Software, and to\r\n    permit persons to whom the Software is furnished to do so, subject to\r\n    the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included\r\n    in all copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/Yonaba/30log/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n\r\n**[[⬆]](#TOC)**","google":"UA-33850683-1","note":"Don't delete this file! It's used internally to help with page regeneration."}